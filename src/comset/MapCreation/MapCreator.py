from __future__ import annotations
import json
import re
from typing import Dict, List, Optional, Set, Tuple, ClassVar, TYPE_CHECKING
from json.decoder import JSONDecodeError

from comset.COMSETsystem.Road import Road
from comset.COMSETsystem.Intersection import Intersection
from comset.COMSETsystem.Vertex import Vertex
from comset.COMSETsystem.CityMap import CityMap
from comset.DataParsing.GeoProjector import GeoProjector
from comset.DataParsing.KdTree import KdTree

if TYPE_CHECKING:
    from COMSETsystem.Configuration import Configuration


class MapCreator:
    """
    Reads the JSON file generated by OpenStreetMaps and creates a directed map based on this file.
    Two types of elements are read from the JSON file, namely "nodes" and "ways". A node can represent
    many things, from a traffic sign, to a road bump, to a point of a road curve, and to an intersection.
    A way is a straight line connecting two nodes. In COMSET, a node is called a "vertex" and a way is
    called a "link". (See class Vertex and Link for more details).

    Once vertices and links are read from the JSON file, the map creator removes all the dead end vertices,
    namely the vertices that have no incoming links or no outgoing links.

    The map creator then identifies the vertices that connect different streets and promote these vertices
    to "intersections". "Roads" are formed to connect intersections. Each road may consists of one or more
    links from the JSON file. For example, if the road between two intersection is a curve, then there may
    be multiple links (and multiple vertices) to provide a polyline approximation of the curve.

    The MapCreator also provides the ability to group vertices. This implies that all the
    vertices which lie within a certain distance of each other are converted to a single vertex.
    This reduces the number of intersections roughly by a factor of 2.
    """

    # Default speed limits in km/h
    SPEED_MOTORWAY = 90
    SPEED_MOTORWAY_LINK = 45
    SPEED_TRUNK = 85
    SPEED_TRUNK_LINK = 40
    SPEED_PRIMARY = 65
    SPEED_PRIMARY_LINK = 30
    SPEED_SECONDARY = 55
    SPEED_SECONDARY_LINK = 25
    SPEED_TERTIARY = 40
    SPEED_TERTIARY_LINK = 20
    SPEED_UNCLASSIFIED = 25
    SPEED_RESIDENTIAL = 25
    SPEED_LIVING_STREET = 10
    SPEED_DEFAULT = 15

    KILOMETERS_PER_MILE = 1.60934  # 1 mile = 1.60934 kilometer

    _bounding_polygon: ClassVar[List[Tuple[float, float]]] = []

    def __init__(self, configuration: Configuration):
        self.minimum_distance = 25
        self.intersections: Dict[int, Intersection] = {}
        self.vertices: Dict[int, Vertex] = {}
        self.id_counter: int = 0
        self._projector: Optional[GeoProjector] = None
        MapCreator._bounding_polygon = self.get_polygon_from_kml(
            configuration.bounding_polygon_kml_file
        )

        try:
            # read file
            with open(configuration.map_json_file, "r", encoding="utf-8") as f:
                data = json.load(f)
                elements = data["elements"]

                # loop over all the elements in the JSON file to set all the vertices
                first_vertex = True
                for element in elements:
                    if element["type"] == "node":
                        node_id = element["id"]
                        lat = element["lat"]
                        lon = element["lon"]
                        if first_vertex:
                            self._projector = GeoProjector(lat, lon)
                            first_vertex = False
                        x, y = (
                            self._projector.from_lat_lon(lat, lon)
                            if self._projector
                            else (0, 0)
                        )
                        self.vertices[node_id] = Vertex(lon, lat, x, y, node_id)

                # loop over all the elements again to set the roads
                for element in elements:
                    if element["type"] == "way":
                        tags = element.get("tags", {})
                        highway = tags.get("highway", "")
                        # set speed limit
                        max_speed = self._get_max_speed(tags, highway)
                        # check if it's a one way street
                        oneway = tags.get("oneway", "") == "yes"

                        # set roads
                        nodes = element["nodes"]
                        for i in range(len(nodes) - 1):
                            from_id = nodes[i]
                            to_id = nodes[i + 1]
                            from_vertex = self.vertices[from_id]
                            to_vertex = self.vertices[to_id]

                            distance = from_vertex.xy.distance(to_vertex.xy)
                            # Convert km/h to meters per second; apply speed reduction
                            simulated_speed = configuration.to_simulated_speed(
                                max_speed * 1000 / 3600
                            )
                            from_vertex.add_edge(to_vertex, distance, simulated_speed)
                            if not oneway:
                                to_vertex.add_edge(
                                    from_vertex, distance, simulated_speed
                                )

        except (FileNotFoundError, JSONDecodeError) as e:
            print(f"Error loading JSON file: {e}")

        self._set_id_counter()

    def _get_max_speed(self, tags: Dict[str, str], highway: str) -> float:
        if "maxspeed" in tags:
            speed_str: str = tags["maxspeed"]
            if "mph" in speed_str:
                mph = int(speed_str.replace(" mph", ""))
                return mph * self.KILOMETERS_PER_MILE  # convert from mph to kmph
            return int(speed_str)
        else:
            return {
                "motorway": self.SPEED_MOTORWAY,
                "motorway_link": self.SPEED_MOTORWAY_LINK,
                "trunk": self.SPEED_TRUNK,
                "trunk_link": self.SPEED_TRUNK_LINK,
                "primary": self.SPEED_PRIMARY,
                "primary_link": self.SPEED_PRIMARY_LINK,
                "secondary": self.SPEED_SECONDARY,
                "secondary_link": self.SPEED_SECONDARY_LINK,
                "tertiary": self.SPEED_TERTIARY,
                "tertiary_link": self.SPEED_TERTIARY_LINK,
                "unclassified": self.SPEED_UNCLASSIFIED,
                "residential": self.SPEED_RESIDENTIAL,
                "living_street": self.SPEED_LIVING_STREET,
            }.get(highway, self.SPEED_DEFAULT)

    def _set_id_counter(self) -> None:
        if self.vertices:
            self.id_counter = max(self.vertices.keys()) + 1
        else:
            self.id_counter = 0

    def create_map(self) -> CityMap:
        # Crop the map using the bounding polygon
        self.crop_map()

        # Consolidate the map by removing dead-end vertices and aggregating close-by vertices.
        self.clear_and_group()

        # Create intersections from vertices that connect different streets.
        self.create_intersections()

        # Create roads from links to connect intersections.
        self.create_roads()

        return self.output_city_map()

    def crop_map(self) -> None:
        """Crop a map using the bounding polygon by removing vertices that are outside the polygon."""
        MapCreator._bounding_polygon.append(MapCreator._bounding_polygon[0])
        to_remove = []
        for vid, vertex in self.vertices.items():
            if not self.inside_polygon(vertex.longitude, vertex.latitude):
                vertex.sever_vertex()
                to_remove.append(vid)
        for vid in to_remove:
            del self.vertices[vid]

    @classmethod
    def inside_polygon(cls, x: float, y: float) -> bool:
        """
        Check if a location (x,y) is inside the bounding polygon.

        Args:
            x: coordinate of the location to check against the polygon
            y: coordinate of the location to check against the polygon

        Return:
            indication of being inside Polygon
        """
        count = 0
        for i in range(len(cls._bounding_polygon) - 1):
            x1, y1 = cls._bounding_polygon[i]
            x2, y2 = cls._bounding_polygon[i + 1]
            try:
                beta = (y - y1) / (y2 - y1)
            except ZeroDivisionError:
                continue
            alpha = x1 + beta * (x2 - x1) - x
            if alpha > 0 and 0 <= beta <= 1:
                count += 1
        count %= 2
        return count != 0

    @staticmethod
    def get_polygon_from_kml(polygon_kml_file: str) -> List[Tuple[float, float]]:
        """
        Construct the bounding polygon from a KML file

        Args:
            polygonKMLFile a KML file defining a polygon
        Returns:
            a polygon represented by a list of [x,y] coordinates
        """
        regex = r"^\s+"
        polygon: List[Tuple[float, float]] = []

        try:
            with open(polygon_kml_file, "r") as f:
                # line = f.readline().rstrip("\n")
                # print(line)
                while line := f.readline().rstrip("\n"):
                    # Remove leading whitespace and check for coordinates tag
                    trimmed_line = re.sub(regex, "", line)
                    if trimmed_line != "<coordinates>":
                        continue
                    while True:
                        line = f.readline().rstrip("\n")
                        if not line:  # Handle unexpected EOF
                            break
                        trimmed_line = re.sub(regex, "", line)
                        if trimmed_line == "</coordinates>":
                            break
                        # Process coordinate data
                        vertices = trimmed_line.split(" ")
                        for vertex in vertices:
                            if not vertex:
                                continue
                            lon_lat = vertex.split(",")
                            if len(lon_lat) < 2:
                                continue
                            pair = (float(lon_lat[0]), float(lon_lat[1]))
                            polygon.append(pair)
                    break  # Only process the first coordinates block
        except IOError as e:
            import traceback

            traceback.print_exc()

        return polygon

    def clear_map_iteration(self) -> None:
        """
        One iteration of the ClearMap function. Goes over every vertex
        and determines if it's a dead end.

        If that's the case then this vertex is removed along with the links
        attached to it.

        In order to fully clear the whole map multiple iterations of this algorithm
        are needed because it is possible that after removing certain vertices
        in the first iteration, previous dead-end streets are now defined by other
        vertices. These vertices then have to be removed in the second
        iteration.
        """
        to_remove = []
        for vid, vertex in self.vertices.items():
            # Remove vertices that have no outgoing roads or incoming roads.
            if not vertex.get_links_from() or not vertex.get_links_to():
                to_remove.append(vid)

        # remove all the vertices that have to be removed
        for vid in to_remove:
            self.vertices[vid].cut_vertex()
            del self.vertices[vid]

    def create_intersections(self) -> None:
        """Identify vertices that connect different streets and promote them to intersections"""
        for vertex in self.vertices.values():
            roads_from, roads_to = vertex.get_links_from(), vertex.get_links_to()
            # Skip vertices that connect two one way links.
            if (len(roads_from) == 1 and len(roads_to) == 1) and not (
                next(iter(roads_from)).to_vertex == next(iter(roads_to)).from_vertex
            ):
                continue

            # if there are two incoming and two outgoing links for a vertex
            # then it's possible that that vertex lies in the middle of
            # a two-way street. Therefore, this has to be checked, and if this is
            # the case it has to be skipped.
            if len(roads_from) == 2 and len(roads_to) == 2:
                check_for_all = True
                for inter_to in vertex.get_adjacent_to():
                    check = False
                    for inter_from in vertex.get_adjacent_from():
                        if inter_to.id == inter_from.id:
                            check = True
                    if not check:
                        check_for_all = False
                if check_for_all:
                    continue

            self.promote_intersection(vertex)

    def promote_intersection(self, vertex: Vertex) -> None:
        """Promote a vertex to an intersection."""
        intersection = Intersection(vertex)
        self.intersections[intersection.id] = intersection
        vertex.intersection = intersection

    def create_roads(self) -> None:
        """Create roads to connect intersections."""
        roads_to_remove: List[Road] = []
        for intersection in self.intersections.values():
            vertex = intersection.vertex
            if vertex is None:
                continue
            for link in vertex.links_map_from.values():
                # create a new empty road
                road = Road()
                road.from_ = intersection

                # extend the road by visiting non-intersection vertices one by one until
                # an intersection is reached
                current_link = link
                while current_link.to_vertex.intersection is None:
                    road.add_link(current_link)
                    for link_from in current_link.to_vertex.links_map_from.values():
                        if link_from.to_vertex != current_link.from_vertex:
                            current_link = link_from
                            break

                # add the link that connects to the end intersection
                road.add_link(current_link)
                road.to = current_link.to_vertex.intersection

                # check if there is duplicate from-to pair
                # in the case of duplicate, keep the shorter road
                to_abandon: Optional[Road] = None
                for aRoad in intersection.roads_map_from.values():
                    if aRoad.to.id == road.to.id:
                        if road.travel_time >= aRoad.travel_time:
                            # abandon new road
                            to_abandon = road
                        else:
                            # abandon old road
                            to_abandon = aRoad
                        break

                if to_abandon is not None:
                    roads_to_remove.append(to_abandon)

                if to_abandon is None or to_abandon.id != road.id:
                    # add new road
                    intersection.roads_map_from[road.to] = road
                    road.to.roads_map_to[intersection] = road

        for road in roads_to_remove:
            self.remove_road(road)

    def remove_road(self, road: Road) -> None:
        # remove intermediate vertices
        for link in road.links:
            self.vertices.pop(link.from_vertex.id, None)
        # remove the from-links of the start vertex
        first_link = road.links[0]
        del first_link.from_vertex.links_map_from[first_link.to_vertex]
        last_link = road.links[-1]
        del last_link.to_vertex.links_map_to[last_link.from_vertex]

    def clear_map(self) -> None:
        """
        Removes all dead end vertices, i.e. the vertices that do not have
        incoming links or outgoing links.
        """
        previous_number_vertices = len(self.vertices)
        new_number_vertices = -2
        while previous_number_vertices != new_number_vertices:
            self.clear_map_iteration()
            previous_number_vertices = new_number_vertices
            new_number_vertices = len(self.vertices)

    def fix_map(self) -> None:
        """Fix the map by removing unreachable vertices and those with no incoming edges."""
        check: bool = True
        while check:
            check = False
            for id, vertex in self.vertices.items():
                if not vertex.get_adjacent_from():
                    vertex.cut_vertex()
                    del self.vertices[id]
                    check = True

            # Check for unreachable vertices
            reached: Set[int] = set()
            first_id = next(iter(self.vertices.keys()))
            first_vertex = self.vertices[first_id]
            self.check_neighbors(first_vertex, reached)
            if len(reached) != len(self.vertices):
                for id, vertex in self.vertices.items():
                    if id not in reached:
                        vertex.cut_vertex()
                        del self.vertices[id]
                        check = True

    def check_neighbors(self, inter: Vertex, reached: Set[int]) -> None:
        # for neighbor in inter.get_adjacent_from():
        #     if neighbor.id not in reached:
        #         reached.add(neighbor.id)
        #         self.check_neighbors(neighbor, reached)
        """
        检查顶点邻居的连通性

        Args:
            inter: 起始顶点
            reached: 已访问顶点ID集合
        """
        stack = [inter]
        while stack:
            current = stack.pop()
            for neighbor in current.get_adjacent_from():
                if neighbor.id not in reached:
                    reached.add(neighbor.id)
                    stack.append(neighbor)

    def clear_and_group(self):
        """
        Combines grouping and clearing of vertices until the map can not
        be simplified any further.

        Accomplished by clearing and grouping until no additional vertices
        are removed
        """
        previous_number_vertices = len(self.vertices)
        # number of vertices.size() can never be negative, therefore it
        # always runs at least once.
        new_number_vertices = -2
        while previous_number_vertices != new_number_vertices:
            self.clear_map()
            # It seems unnecessary to group vertices given the size of the map we are considering.
            # groupVertices();
            previous_number_vertices = new_number_vertices
            new_number_vertices = len(self.vertices)
        self.fix_map()

    def output_city_map(self) -> CityMap:
        """Returns an instance of CityMap representing the map it created."""
        kd_tree = KdTree()
        for vertex in self.vertices.values():
            for link in vertex.get_links_from():
                kd_tree.insert(link)
        roads: List[Road] = []
        for intersection in self.intersections.values():
            roads.extend(intersection.get_roads_from())
        # set road speed
        for road in roads:
            road.set_speed()

        return CityMap(self.intersections, roads, self._projector, kd_tree)

    @property
    def bounding_polygon(self) -> List[Tuple[float, float]]:
        return MapCreator._bounding_polygon

    @property
    def projector(self) -> GeoProjector:
        return self._projector
